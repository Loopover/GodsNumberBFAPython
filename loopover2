#! /usr/bin/python3

#import pyximport; pyximport.install(pyimport=True)

import copy
from multiprocessing import Pool
import multiprocessing
from collections import Counter
import linecache
import itertools
import defs2
import tracemalloc
import os
from datetime import datetime
pool = Pool(multiprocessing.cpu_count())
#pool = Pool(1)

checkMem = False

timeStart = datetime.today()

#boards = [[[[1],[2],[3],[4],[5]],[[6],[7],[8],[9],[10]],[[11],[12],[13],[14],[15]],[[16],[17],[18],[19],[20]],[[21],[22],[23],[24],[25]]]]
boards = [((1,2,3,4),(5,6,7,8),(9,10,11,12),(13,14,15,16))]
#boards = [((1,2,3),(4,5,6),(7,8,9))]
#boards = [((1,2),(3,4))]

boards = set(boards)

found = True
number = 0
depth = 0

def display_top(snapshot, key_type='lineno', limit=3):
	snapshot = snapshot.filter_traces((
		tracemalloc.Filter(False, "<frozen importlib._bootstrap>"),
		tracemalloc.Filter(False, "<unknown>"),
	))
	top_stats = snapshot.statistics(key_type)

	print("Top %s lines" % limit)
	for index, stat in enumerate(top_stats[:limit], 1):
		frame = stat.traceback[0]
		# replace "/path/to/module/file.py" with "module/file.py"
		filename = os.sep.join(frame.filename.split(os.sep)[-2:])
		print("#%s: %s:%s: %.1f KiB" % (index, filename, frame.lineno, stat.size / 1024))
		line = linecache.getline(frame.filename, frame.lineno).strip()
		if line:
			print('    %s' % line)

	other = top_stats[limit:]
	if other:
		size = sum(stat.size for stat in other)
		print("%s other: %.1f KiB" % (len(other), size / 1024))
	total = sum(stat.size for stat in top_stats)
	print("Total allocated size: %.1f KiB" % (total / 1024))

def uniq(lst):
	last = object()
	for item in lst:
		if item == last:
			continue
		yield item
		last = item

def sort_and_deduplicate(l):
	return list(uniq(sorted(l, reverse=True)))

boardsc =copy.deepcopy(boards)
print("Init took: "+str(datetime.today()-timeStart))
timeLast = datetime.today()
if checkMem: 
	tracemalloc.start()
while found:
	found = False
#	for i, board in enumerate(boardsc):
#		tmpnumber, tmpboards, tmpFound = getFound(i,board)
#		number += tmpnumber
#		boards += tmpboards
#		found = found or tmpFound
	results = pool.starmap(defs2.getFound, zip(boardsc,itertools.repeat(boards)), int(len(boardsc)/multiprocessing.cpu_count())+1)
	oldBoards = boardsc
	boardsc = set()
	tmpNumberAgain = 0
	for result in results:
		tmpnumber, tmpboards, tmpFound = result
		tmpNumberAgain += tmpnumber
		boards.update(tmpboards)
		found = found or tmpFound
		boardsc.update(tmpboards)
	number += tmpNumberAgain
	if not found :
		boardsc = oldBoards
	#print()
	depth += 1
	print("Number of combos tested: " + str(number))
	print("Number of combos unique: " + str(len(boards)))
	print("Depth: " + str(depth))
	tmpTime = datetime.today()-timeLast
	print("Took: "+str(tmpTime))
	print("Boards per seccond: "+str(tmpNumberAgain/(tmpTime).total_seconds()))
	timeLast = datetime.today()
	tmpTime = datetime.today()-timeStart
	print("Total: "+str(tmpTime))
	print("Overall boards per seccond: "+str(number/(tmpTime).total_seconds()))
	print()
print("Number of combos tested:"+str(number))
print("Number of unique combos:"+str(len(boards)))
print("Depth:"+str(depth-1))
tmpTime = datetime.today()-timeStart
print("Total Time:"+str(str(tmpTime)))
print("Overall boards per seccond: "+str(number/(tmpTime).total_seconds()))
print("Total size of boards: "+str(boards.__sizeof__())+" bytes")
if checkMem:
	snapshot = tracemalloc.take_snapshot()
	display_top(snapshot)
#list(map(print,boardsc))
pool.close()

file_object  = open("tmp", "w")
def writeTheThing(theThing):
	file_object.write(str(theThing))
list(map(writeTheThing,boardsc))
